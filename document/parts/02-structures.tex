\chapter{Extended Logical Structures}\label{chapter2}

The aim of this section is to construct from a given contextual category $\sfC$
with extra structure another contextual category $\sfC^{\cxt}$ with the same
structure, but where objects are iterated context extensions, compatibly with a
canonical contextual functor $\sfC\hookrightarrow\sfC^{\cxt}$ defining an
equivalence on the underlying categories, thereby
generalizing our structures from simple context extensions to arbitrary ones.
Indeed, we may then take a context extension, look at it in $\sfC^{\cxt}$, apply
the construction and then carry it back through the equivalence. This extension
shall be heavily exploited in the final part of the thesis. This technique has
been mentioned multiple times in the literature to justify various results at a
certain level of generality, however nobody actually carried out the necessary
constructions.

\section{Constructions}

On the type theoretical side, extensions of logical rules for $\Ids$-types to
contexts were first explored by Streicher \cite{Str93}, then by Gambino and
Garner \cite{GG08,Gar09b} under the name of \emph{identity contexts}, also
called $\Ids$-contexts.

\begin{notation}
  We shall make use of their notation \cite[4]{GG08} in the second part of this
  section and the final chapter of this thesis to study $\Syn{\T}$, meaning that
  we abbreviate the sequence of judgements
  \[\Gamma\vdash A_1\type,\]
  \[\Gamma,a_1:A_1\vdash A_2(a_1)\type,\]
  \[\vdots\]
  \[\Gamma,a_1:A_1,\ldots,a_{n-1}:A_{n-1}(a_1,\ldots,a_{n-2})\vdash
  A_n(a_1,\ldots,a_{n-1})\type\]
  by
  \[\Gamma\vdash\Delta\context,\]
  in which case $\Delta$ is a \emph{dependent context in context $\Gamma$} and
  we shall write that $\Delta=A_1,\ldots,A_n$ as a shorthand.
  Similarly,
  \[\Gamma\vdash x:\Delta\]
  abbreviates
  \begin{align*}
    \Gamma &\vdash a_1:A_1, \\
    \Gamma,a_1:A_1 &\vdash a_2:A_2(a_1), \\
    \vdots & \\
    \Gamma,a_1:A_1,\ldots,a_{n-1}:A_{n-1}(a_1,\ldots,a_{n-2})
           &\vdash a_n:A_n(a_1,\ldots,a_{n-1})
  \end{align*}
  and then $x$ is a \emph{dependent term of $\Delta$ in context $\Gamma$}, which
  can be thought of as a tuple $(a_1,\ldots,a_n)$. Furthermore,
  \[\Gamma,x:\Delta\vdash\Theta(x)\context\]
  specifies the dependency of $\Theta$ on the term $x:\Delta$ in context
  $\Gamma$.

  \noindent
  It is also possible to introduce further expressions, like
  \[\Gamma\vdash \Delta\equiv\Theta\context\]
  for judgmental equality between dependent contexts and
  \[\Gamma\vdash x\equiv x':\Delta,\]
  for judgmental equality between dependent terms, defined as pointwise
  judgmental equalities. The details are straightforward and therefore omitted.
\end{notation}
\noindent

\noindent
Lumsdaine claimed that it is possible to provide extensions of the logical
structures we are studying in \cite[Rem.\ 1.3.1]{Lum10}. At the
time Kapulkin proved the theorem this thesis focuses on,
nothing further was available in the literature and only later him and
Lumsdaine gave more details on these matters \cite{KL18}. In this section we aim
to partially fix that for $\Pis$-structures specifically, which will be the main
contribution of this work. It should be noted that, imitating Gambino and
Garner, we may derive the
corresponding logical rules for what would then be called $\Pis$-contexts,
however we will not do so and focus on the semantics, believing that the
translation should be straightforward and a simple duplication of work. We will
later sketch the extension for $\Sigmas$-structures.

\noindent
We begin by constructing the category of iterated contexts, where we
will extend the structures.

\begin{construction}\cite[21]{Lum10}
  Given a contextual category $\sfC$, we construct a contextual category
  $\sfC^{\cxt}$ in the following way:
  \begin{enumerate}
    \item the set $\Ob_n\sfC^{\cxt}$ is given by $n$-iterated non-trivial context
      extensions
      \[\Gamma_1.\Gamma_2.\ldots.\Gamma_n\]
      in $\sfC$;
    \item morphisms
      $\Gamma_1.\Gamma_2.\ldots.\Gamma_n\rightarrow\Delta_1.\Delta_2.\ldots.\Delta_m$
      are morphisms between them seen as objects of $\sfC$;
    \item $*$ is the only element of $\Ob_0\sfC^{\cxt}$;
    \item
      $\cft(\Gamma_1.\Gamma_2.\ldots.\Gamma_n.\Gamma_{n+1})=\Gamma_1.\Gamma_2.\ldots.\Gamma_n$;
    \item the map $p_{\Gamma_1.\Gamma_2.\ldots.\Gamma_n.\Gamma_{n+1}}\colon
      \Gamma_1.\Gamma_2.\ldots.\Gamma_{n+1}\rightarrow
      \Gamma_1.\Gamma_2.\ldots.\Gamma_n$ is the dependent projection exhibiting
      $\Gamma_1.\Gamma_2.\ldots.\Gamma_{n+1}$ as a context extension of
      $\Gamma_1.\Gamma_2.\ldots.\Gamma_n$;
    \item the chosen pullbacks are given by iterating the pullbacks along the
      basic dependent projections, as in the original contextual category.
  \end{enumerate}

  \noindent
  As we can see, any object of $\sfC^{\cxt}$ either is the empty context or is
  isomorphic to one in
  $\Ob_1\sfC^{\cxt}$, that is the one which we get by looking at the associated object
  in $\sfC$ and then taking the dependent projection from it to the terminal
  object, which exhibits it as a 1-iterated context extension. The isomorphism
  is then given by the map in $\sfC^{\cxt}$ corresponding to the identity of the
  object in $\sfC$. We now specify a monad $\sfC\mapsto\sfC^{\cxt}$ on $\Cxl$.

  \noindent
  The unit $\sfC\rightarrow\sfC^{\cxt}$ sends every $n$-object in $\sfC$ to
  the corresponding $n$-iterated (simple) context extension and every morphism
  to the one it represents.

  \noindent
  Before we construct the multiplication, let's study this contextual functor.
  Every $n$-iterated
  context in $\sfC^{\cxt}$ is isomorphic to one in the image of the unit, namely
  the one which we get by reducing it to an iterated simple context extension,
  meaning that the functor is essentially surjective. Also, it is fully faithful
  by construction and therefore it defines an equivalence on the underlying
  categories.

  \noindent
  Let's construct the multiplication. An $n$-object of $(\sfC^{\cxt})^{\cxt}$ is an
  $n$-iterated context extension where each extension is itself an iterated
  context extension in $\sfC$, that is
  \[(\Gamma_1.\ldots.\Gamma_{i_1}).(\Gamma_{i_1+1}.\ldots.\Gamma_{i_2}).\ldots.(\Gamma_{i_{n-1}+1}.\ldots.\Gamma_{i_n}).\]
  Since composing dependent projections gives dependent projections,
  seeing $\Gamma_{i_{j-1}+1}.\ldots.\Gamma_{i_j}$ as a single context extension
  $\Delta_j$ in $\sfC$, we can naturally
  map the object of $(\sfC^{\cxt})^{\cxt}$ to $\Delta_1.\ldots.\Delta_n$ in
  $\sfC^{\cxt}$ and, again, every morphism
  in $(\sfC^{\cxt})^{\cxt}$ corresponds to a unique one in $\sfC^{\cxt}$ once we
  specify domain and codomain. By construction, this functor is again contextual
  and an equivalence of categories.

  \noindent
  The monad axioms follow from the fact that, essentially, both unit and
  multiplication are ``identities'' on objects and morphisms.
\end{construction}

\begin{prop}
  The above construction defines a monad on $\Cxl$.
\end{prop}

  \noindent
For the construction of the $\Ids$-structure on $\Syn{T}^{\cxt}$ it is
enough to translate the logical rules for $\Ids$-context we mentioned earlier. A
sketch of the construction on $\sfC^{\cxt}$ for an
arbitrary contextual category with an $\Ids$-structure $\sfC$ is available in
\cite[Constr.\ 2.17]{KS19}.

  \noindent
We are now ready, given a contextual category $\sfC$, to extend the
$\Pis$-structure to $\sfC^{\cxt}$. We shall do so in two parts, first in full
generality and then under extra assumptions.

  \noindent
Given $\Gamma.\Delta.\Theta$ in $\sfC^{\cxt}$, where
$l(\Gamma.\Delta.\Theta)=l(\Gamma.\Delta)+n=l(\Gamma)+m+n$ in $\sfC$, we
build $\Gamma.\Pis(\Delta,\Theta)$ by induction on the length of the context
extensions involved, taking the
one from $\sfC$ in case we are working with objects corresponding to simple
extensions.

\begin{construction}[Part 1]
  If $n=0$, then
  \begin{align*}
    \Gamma.\Pis(\Delta,\Theta) &=\Gamma, \\
    \app_{\Delta,\Theta} &=1_{\Gamma.\Delta}, \\
    \lambda_{\Delta,\Theta}(b) &=1_\Gamma.
  \end{align*}
  Notice that the only possible section $b$ in the latter case is given by
  $1_{\Gamma.\Theta}$. This is not really necessary to specify the
  $\Pis$-structure, however we shall need it later in Lemma \ref{radj}.

  \noindent
  We now work with the case where $m>0$, $n=1$, thus we can write
  $\Gamma.\Delta.\Theta=\Gamma.\Delta.B$. In the base case, $m=1$, we have
  $\Gamma.\Delta=\Gamma.A$ and therefore have to simply set our structure to
  coincide with the one in $\sfC$.

  \noindent
  If $n-1>0$, we have, for a section
  $b\colon\Gamma.\Delta\rightarrow\Gamma.\Delta.B$,
  $\Gamma.\Delta=\Gamma.\Delta'.A$ and then set
  \begin{align*}
    \Gamma.\Pis(\Delta,B)
    &=\Gamma.\Pis(\Delta'.A,B)=\Gamma.\Pi(\Delta',\Pi(A,B)), \\
    \app_{\Delta,B}
    &\colon
    \Gamma.\Pis(\Delta',\Pi(A,B)).\Delta'.A
                    \xrightarrow{q(\app_{\Delta',\Pis(A,B)},p^*_{\Pi(A,B)}A)} \\
    &\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad
    \Gamma.\Delta'.\Pi(A,B).A
    \xrightarrow{\app_{A,B}}
    \Gamma.\Delta'.A.B, \\
    \lambda_{\Delta,B}(b)
    &\colon
    \Gamma
    \xrightarrow{\lambda_{\Delta',\Pis(A,B)}(\lambda_{A,B}(b))}
    \Gamma.\Pis(\Delta',\Pi(A,B)).
  \end{align*}
  The idea here is to replicate the adjunction $\Set(A\times
  B,C)\cong\Set(A,\Set(B,C))$. The map $\app_{\Delta,B}$ is then naturally
  interpreted as a sequence of partial evaluations and the phenomenon is
  commonly known as \emph{currying-uncurrying}.
\end{construction}

  \noindent
  We have dealt with the construction for $n=1$ in $\sfC$, hence we shall move
  on to the case where $\Delta$ has arbitrary length and induct on $n$.

  \noindent
We will work only with syntactic categories and in contextual categories where a
section $x\colon\Gamma\rightarrow\Gamma.A.B$ can be split as
two sections $a\colon\Gamma\rightarrow\Gamma.A$,
$b\colon\Gamma.A\rightarrow\Gamma.A.B$.
We see that $p_B\cdot x=p_B\cdot b\cdot a=a$. Syntactically, this means that if
we pick two terms $a:A,b:B(a)$ over $\Gamma$ at once, then we can also
specify for each choice of a term $a':A$ over $\Gamma$ a term $b':B(a')$ such
that $b\equiv b'$ when $a\equiv a'$. We later point out the
difficulties encountered without our assumption and exploit our previously
presented notation for extended type-theoretic rules to reason about
$\Syn{T}^{\cxt}$ as if we were working with $\Syn{T}$.

\begin{construction}[Part 2]
  Suppose that
  $l(\Gamma.\Delta.\Theta)=l(\Gamma.\Delta)+n$, $n>1$, and we have already
  provided the relevant constructions up to $n-1$. We again decompose
  the context as $\Gamma.\Delta.\Theta'.B$.

  \noindent
  If we are working with a contextual category $\sfC$ where sections split, we
  make use of our assumption on a section
  $y\colon\Gamma.\Delta\rightarrow\Gamma.\Delta.\Theta'.B$ to get a
  factorization as $b\cdot y'$ through $\Gamma.\Delta.\Theta'$.
  \begin{align*}
    \Gamma.\Pis(\Delta,\Theta)
    &=\Gamma.\Pis(\Delta,\Theta'.B)=\Gamma.\Pi(\Delta,\app^*_{\Delta,\Theta'}B), \\
    \app_{\Delta,\Theta}
    &\colon\Gamma.\Pis(\Delta,\Theta').\Pi(\Delta,\app^*_{\Delta,\Theta'}B).\Delta
    \xrightarrow{\app_{\Delta,\app^*_{\Delta,\Theta'}B}} \\
    &\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad
    \Gamma.\Pis(\Delta,\Theta').\Delta.\app^*_{\Delta,\Theta'}B
    \xrightarrow{q(\app_{\Delta,\Theta'},B)}
    \Gamma.\Delta.\Theta'.B, \\
    \lambda_{\Delta,\Theta}(y)
    &\colon\Gamma
    \xrightarrow{\lambda_{\Delta,\Theta'}(y')}
    \Gamma.\Pis(\Delta,\Theta')
    \xrightarrow{\lambda_{p^*_{\Pis(\Delta,\Theta')}\Delta,\app^*_{\Delta,\Theta'}B}(\app_{\Delta,\Theta'}^*b')}
    \Gamma.\Pis(\Delta,\Theta').\Pi(\Delta,\app^*_{\Delta,\Theta'}B).
  \end{align*}

  \noindent
  If we are instead in $\Syn{T}$, we can define $\lambda_{\Delta,\Theta}(y)$ in
  the following way: from $y'(x):\Theta(x),b(x,y'(x)):B(x,y'(x))$ in context
  $\Gamma,x:\Delta$ we can indeed simply take the section specified
  by $\lambda(x:\Delta).y(x):\Pis(\Delta,\Theta)$ that is the pair
  \begin{align*}
    \lambda(x:\Delta).y'(x): &\Pis(\Delta,\Theta'), \\
    \lambda(x:\Delta).b'(x,y'(x)): &\Pis(x:\Delta,B(\app(\lambda(x:\Delta).y'(x),x))),
  \end{align*}
  where we have made explicit the dependencies of the type $B$.

  \noindent
Finally, given $a\colon\Gamma\rightarrow\Gamma.\Delta$,
$f\colon\Gamma.\Delta\rightarrow\Gamma.\Delta.\Theta$, we construct
$\app_{\Delta,\Theta}(f,x)$ for sections
$f\colon\Gamma\rightarrow\Gamma.\Pis(\Delta,\Theta)$,
$x\colon\Gamma\rightarrow\Gamma.\Delta$ as in the definition of
$\Pis$-structures \ref{appcomposed}.
\end{construction}

  \noindent
This fully specifies the data needed for a $\Pis$-structure on $\sfC^{\cxt}$,
however we still have to check that it is indeed one, which we will do in the
next section. First, however, we sketch the extension for $\Sigmas$-structures
by assuming to have a left inverse $\unpair_{A,B}$
of $\pair_{A,B}$ for any context $\Gamma.A.B$. Such a left inverse can be
constructed in $\Syn{T}$ by looking at the projection maps described in
\cite[Sec.\ 1.6]{Uni13}.

\begin{construction}
  Let $\sfC$ be a contextual category with a $\Sigmas$-structure. Given a
  dependent context $p_\Delta\colon\Gamma.\Delta.\Theta\rightarrow\Gamma.\Delta$
  with $l(\Gamma.\Delta.\Theta)=l(\Gamma.\Delta)+n=l(\Gamma)+m+n$ in $\sfC$ we
  proceed by induction on $m,n>0$.

  \noindent
  Let's fix $m=1$. If $n=1$, like for $\Pis$-structures we are forced to take
  the definition from $\sfC$, so we can focus on $n>1$. We have then
  $\Gamma.\Delta.\Theta=\Gamma.A.B.\Theta'$, so we take
  \begin{align*}
    \Gamma.\Sigmas(A,\Theta)
    &=\Gamma.\Sigmas(A,B.\Theta')
    =\Gamma.\Sigmas(A,\Sigmas(B,\Theta')), \\
    \pair_{A,\Theta}
    &\colon
    \Gamma.A.B.\Theta'
    \xrightarrow{\pair_{B,\Theta'}}
    \Gamma.A.\Sigmas(B,\Theta')
    \xrightarrow{\pair_{A,\Sigmas(B,\Theta')}}
    \Gamma.\Sigmas(A,\Sigmas(B,\Theta')).
  \end{align*}

  \noindent
  To deal with the case where $m>1$ and therefore
  $\Gamma.\Delta.\Theta=\Gamma.\Delta'.A.\Theta$, we choose
  \begin{align*}
    \Gamma.\Sigmas(\Delta,\Theta)
    &=\Gamma.\Sigmas(\Delta'.A,\Theta)
    =\Gamma.\Sigmas(\Delta',A.\Theta), \\
    \pair_{\Delta,\Theta}
    &=\pair_{\Delta',A.\Theta}.
  \end{align*}

  \noindent
  To complete the construction, one has to define for all maps
  \[z\colon\Gamma.\Delta.\Theta\rightarrow\Gamma.\Sigmas(\Delta,\Theta).\Psi\]
  such that $p_\Psi\cdot z=\pair_{\Delta,\Theta}$ a section
  \[\csplit_z\colon\Gamma.\Sigmas(\Delta,\Theta)
  \rightarrow\Gamma.\Sigmas(\Delta,\Theta).\Psi\]
  satisfying
  $\csplit_z\cdot\pair_{\Delta,\Theta}=z$ and it is here that one uses the
  morphism $\unpair_{\Delta,\Theta}$.
\end{construction}

\section{Properties}

In this section we verify that the desired properties hold for our
constructions.

\begin{lem}\label{extpistruct}
  Given a dependent type theory with $\Pis$-types $\T$, the data provided
  defines a $\Pis$-structure on $\Syn{T}^{\cxt}$ which is
  compatible with the natural contextual functor
  $\Syn{T}\hookrightarrow\Syn{T}^{\cxt}$.
\end{lem}
\begin{proof}
  We have to
  show that it is a $\Pis$-structure, which we will do inductively by verifying
  that at every step our proposed construction maintains the desired properties.
  The compatibility with the contextual functor will then follow directly from
  the way we defined the base case.

  \noindent
  Let's consider an object $\Gamma.\Delta.\Theta$ in $\Syn{T}^{\cxt}$ such that
  $l(\Gamma.\Delta.\Theta)=l(\Gamma.\Delta)+n=l(\Gamma)+m+n$ in $\Syn{T}$. The
  only interesting case is the one where least one of $m,n$ is
  $>1$: indeed, the desired properties in the other cases are
  follow directly from the fact that they hold in $\Syn{T}$.

  \noindent
  We start as before by working on $m>1$, $n=1$, so we write
  $\Gamma.\Delta.\Theta=\Gamma.\Delta.B=\Gamma.\Delta'.A.B$ and assume that
  the desired properties hold for shorter context extensions.
  Picking a section $b\colon\Gamma.\Delta\rightarrow\Gamma.\Delta.B$, we can
  then write
  \begin{align*}
    p_B\cdot\app_{\Delta,B}
    &=p_B\cdot
    \app_{A,B}\cdot
    q(\app_{\Delta',\Pis(A,B)},p^*_{\Pi(A,B)}A) \\
    &=q(p_{\Pis(A,B)},A)\cdot
    q(\app_{\Delta',\Pis(A,B)},p^*_{\Pi(A,B)}A) \\
    &=q(p_{\Pis(A,B)}\cdot\app_{\Delta',\Pi(A,B)},A) \\
    &=q(q(p_{\Pis(\Delta',\Pi(A,B))},\Delta'),A) \\
    &=q(p_{\Pis(\Delta',\Pi(A,B))},\Delta'.A) \\
    &=q(p_{\Pis(\Delta,B)},\Delta) \\
    p_B\cdot\app_{\Delta,B}(f,a)
    &=p_B\cdot
    \app_{\Pis(\Delta,B)}\cdot
    (f,a) \\
    &=q(p_{\Pis(\Delta,B)},\Delta)\cdot
    (f,a) \\
    &=a \\
    p_{\Pis(\Delta,B)}\cdot\lambda_{\Delta,B}(b)
    &=p_{\Pis(\Delta',\Pi(A,B))}\cdot
    \lambda_{\Delta',\Pis(A,B)}(\lambda_{A,B}(b)) \\
    &=1_\Gamma.
  \end{align*}
  To justify $\app_{\Delta,B}(\lambda_{\Delta,B}(b),x)=b\cdot x$ we shall work
  type-theoretically. The section
  $b$ is such that\[x\equiv (x',a)\mapsto(x',a,b(x',a))\equiv(x,b(x)),\] thus
  applying $\lambda_{A,B}$ and then $\lambda_{\Delta',\Pis(A,B)}$ we get
  \[\lambda(x':\Delta').(\lambda(a:A).b(x',a))
  \equiv\lambda(x:\Delta).b(x):\Gamma.\Pis(\Delta,B).\]
  Also, $\app_{\Delta,B}$ acts as
  \begin{align*}
    (f,x) \\
    ^{\text{split } x}&\equiv(f,x',a) \\
    ^{q(\app_{\Delta',\Pis(A,B)},p^*_{\Pi(A,B)}A)}&\mapsto
    (x',\app(f,x'),a) \\
    ^{\app_{A,B}}&\mapsto
    (x',a,\app(\app(f,x'),a)) \\
    &\equiv(y,\app(f,y)),
  \end{align*}
  thus in this case we get
  \begin{align*}
    (\lambda(x:\Delta).b(x),x) \\
    &\equiv(\lambda(x':\Delta').(\lambda(a:A).b(x',a)),x',a) \\
    &\mapsto
    (x',\lambda(a:A).b(x',a),a) \\
    &\mapsto
    (x',a,b(x',a)) \\
    &\equiv(x,b(x)),
  \end{align*}
  where the inductive hypothesis has been used in the second step.
  
  \noindent
  We now check inductively on the length of $\Theta$.
  \begin{align*}
    p_{\Theta}\cdot\app_{\Delta,\Theta}
    &=p_{\Theta'}\cdot
    p_B\cdot
    q(\app_{\Delta,\Theta'},B)\cdot
    \app_{\Delta,\app^*_{\Delta,\Theta'}B} \\
    &=p_{\Theta'}\cdot
    \app_{\Delta,\Theta'}\cdot
    p_{\app^*_{\Delta,\Theta'}B}\cdot
    \app_{\Delta,\app^*_{\Delta,\Theta'}B} \\
    &=q(p_{\Pis(\Delta,\Theta)},\Delta)\cdot
    q(p_{\Pis(\Delta,\app^*_{\Delta,\Theta'}B)},\Delta) \\
    &=q(p_{\Pis(\Delta,\Theta')}\cdot
    p_{\Pis(\Delta,\app^*_{\Delta,\Theta'}B)},\Delta) \\
    &=q(p_{\Pis(\Delta,\Theta').\Pi(\Delta,\app^*_{\Delta,\Theta'}B)},\Delta) \\
    &=q(p_{\Pis(\Delta,\Theta)},\Delta) \\
    p_\Theta\cdot\app_{\Delta,\Theta}(f,x)
    &=p_\Theta\cdot\app_{\Delta,\Theta}\cdot(f,x) \\
    &=q(p_{\Pis(\Delta,\Theta)},\Delta)\cdot(f,x) \\
    &=x \\
    p_{\Pis(\Delta,\Theta)}\cdot
    \lambda_{\Delta,\Theta}(y)
    &=p_{\Pis(\Delta,\Theta')}\cdot
    p_{\Pis(p_{\Pi(\Delta,\Theta')}^*\Delta,\app^*_{\Delta,\Theta'}B')}\cdot
    \lambda_{p^*_{\Pis(\Delta,\Theta')}\Delta,\app^*_{\Delta,\Theta'}B}(\app_{\Delta,\Theta'}^*b)\cdot
    \lambda_{\Delta,\Theta'}(y) \\
    &=p_{\Pis(\Delta,\Theta')}\cdot
    \lambda_{\Delta,\Theta'}(y) \\
    &=1_\Gamma.
  \end{align*}
  Again, to justify
  $\app_{\Delta,\Theta}(\lambda_{\Delta,\Theta}(y),x)=y\cdot x$ we use
  type-theoretic reasoning.
  Splitting $y:\Theta(x)$ in context $\Gamma,x:\Delta$ as $(y'(x),b(x,y'))$, we
  know that $y\colon\Gamma.\Delta\rightarrow\Gamma.\Delta.\Theta$ acts as
  \[x\mapsto(x,y(x))\equiv(x,y'(x),b(x,y'(x))),\]
  thus our construction provides us with
  \[\lambda(x:\Delta).y(x)\equiv
  (\lambda(x:\Delta).y'(x),\lambda(x:\Delta).b(x,y'(x))).\]
  Also, $\app_{\Delta,\Theta}$ acts internally as
  \begin{align*}
    (f,x) \\
    ^{\text{split }f}&\equiv(f',f'',x) \\
    ^{\app_{\Delta,\app^*_{\Delta,\Theta'}B}}&\mapsto(f',x,\app(f'',x)) \\
    ^{q(\app_{\Delta,\Theta'},B)}&\mapsto(x,\app(f',x),\app(f'',x)) \\
    &\equiv(x,\app(f,x)),
  \end{align*}
  which here translates to
  \begin{align*}
    (\lambda(x:\Delta).y(x),x) \\
    &\equiv(\lambda(x:\Delta).y'(x),\lambda(x:\Delta).b(x,y'(x)),x) \\
    &\mapsto(\lambda(x:\Delta).y'(x),x,b(x,y'(x))) \\
    &\mapsto(x,y'(x),b(x,y'(x))) \\
    &\equiv(x,y(x)),
  \end{align*}
  where the inductive hypothesis has been used in the second step.

  \noindent
  To conclude the proof one would still need to verify that the construction is
  compatible with context substitution.
\end{proof}

\begin{rmk}
  The above theorem can be generalized to contextual categories with a
  $\Pis$-structure $\sfC$ as long as sections of dependent projections can be
  factored as described, in which case this hypothesis is used when we split
  dependent terms. If we can't, we are unable to show that
  $\app_{\Delta,\Theta}(\lambda_{\Delta,\Theta}(y),x)=y\cdot x$, and in fact we
  can not even produce $\lambda_{\Delta,\Theta}(y)$ the way we did in the case
  where $m>1$. The proof is essentially the same, albeit harder to read.
\end{rmk}

  \noindent
We shall also need the following lemma.

\begin{lem}[{\cite[Lem.\ 5.6]{Kap17}}]\label{piequal}
  Given a dependent type theory with $\Pis$-types $\T$ and an iterated context
  extension $\Gamma.\Delta.\Theta.\Psi$ in $\Syn{T}$, the contexts
  \[\Gamma.\Pis(\Delta,\Theta.\Psi),\quad\Gamma.\Pis(\Delta,\Theta).\Pis(p^*_{\Pis(\Delta,\Theta)}\Delta,\app^*_{\Delta,\Theta}\Psi)\]
  are equal in $\Syn{T}$. Also,
  $\Gamma.\Pis(\Delta,p_{\Psi})=p_{\Pis(\Delta,\app^*_{\Delta,\Theta}\Psi)}$.
\end{lem}
\begin{proof}
  For the first claim, it is enough to notice that the two contexts reduce to
  the same one in $\Syn{T}$ after applying the inductive construction we defined
  on $\Syn{T}^{\cxt}$ to reduce $\Psi$.

  \noindent
  For the second claim instead we consider the chain of equalities
  \begin{align*}
    \Gamma.\Pis(\Delta,p_{\Psi})
    &=q(p_{\Pis(\Delta,\Theta.\Psi)},\Pis(\Delta,\Theta))\cdot
    \lambda_{\Delta,\Theta}(1_{p^*_{\Pis(\Delta,\Theta)}\Delta},p_\Psi\cdot\app_{\Delta,\Theta.\Psi}) \\
    &=p_{\Pis(\Delta,\app^*_{\Delta,\Theta}\Psi)}\cdot
    p_{\Pis(\Delta,\Theta)}\cdot
    \lambda_{\Delta,\Theta}(1_{p^*_{\Pis(\Delta,\Theta)}\Delta},p_\Psi\cdot\app_{\Delta,\Theta.\Psi}) \\
    &=p_{\Pis(\Delta,\app^*_{\Delta,\Theta}\Psi)},
  \end{align*}
  which can be checked type-theoretically.
\end{proof}

  \noindent
We conclude by presenting the following propositions without proof. It is worth
noting that the original statements mention contextual categories, but to do so
they rely on the Initiality Conjecture \ref{initconj} and here our focus is on
syntactic categories.

\begin{lem}[{\cite[Prop.\ 3.3.1]{Gar09b}}]
  Given a dependent type theory with $\Ids$-types $\T$, the contextual category
  $\Syn{T}^{\cxt}$ carries a natural $\Ids$-structure compatible with the
  natural contextual functor $\Syn{T}\hookrightarrow\Syn{T}^{\cxt}$.
\end{lem}

\begin{lem}[{\cite[Lemma 2.28]{KS19}}]
  Given a dependent type theory with $\Ids$- and $\Piext$-types
  $\T$, the latter can also be lifted from $\Syn{T}$ to
  $\Syn{T}^{\cxt}$ compatibly with the natural contextual functor
  $\Syn{T}\hookrightarrow\Syn{T}^{\cxt}$.
\end{lem}

\begin{rmk}
  Lumsdaine noted in \cite[Rem.\ 1.3.1]{Lum10} that such extended structures are
  not all compatible with the monad we presented earlier, but we will not be
  needing it.
\end{rmk}
